# Copyright 2024 GlyphyAI

# Use of this source code is governed by an MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT.

from collections.abc import Callable, Sequence
from copy import copy
from dataclasses import dataclass
from types import UnionType
from typing import (
    Annotated,
    Any,
    Literal,
    TypeAlias,
    TypeGuard,
    TypeVar,
    Union,
    Unpack,
    get_args,
    get_origin,
)

from pydantic import BaseModel, ValidationError, create_model
from pydantic.fields import FieldInfo, _FromFieldInfoInputs
from pydantic_core import PydanticUndefined

T = TypeVar("T", bound=BaseModel)
V = TypeVar("V", bound=BaseModel)

DEFAULT_VALUE_TYPE: TypeAlias = Literal["__DEFAULT_VALUE__"]
DEFAULT_VALUE_PLACEHOLDER: DEFAULT_VALUE_TYPE = "__DEFAULT_VALUE__"


@dataclass
class DefaultValueContainer:
    """Container to hold default value information for a model field.

    Attributes:
        value: The static default value
        factory: A callable that generates the default value
    """

    value: Any | None
    factory: Callable | None

    def get_default(self) -> Any:
        """Retrieve the default value.

        Returns:
            The default value, either static or generated by the factory
        """
        if self.value is not None:
            return self.value
        if self.factory is not None:
            return self.factory()
        return None

    def __hash__(self) -> int:
        return hash((self.value, self.factory))


def is_pydantic_model(model: Any) -> TypeGuard[type[BaseModel]]:
    """Check if the provided model is a subclass of Pydantic's BaseModel.

    Args:
        model: The model to check.

    Returns:
        TypeGuard[type[BaseModel]]: True if it's a Pydantic BaseModel subclass, False otherwise.
    """
    return (
        model is not None
        and not get_origin(model)
        and isinstance(model, type)
        and issubclass(model, BaseModel)
    )


def copy_field_info(
    field_info: FieldInfo,
    exclude_attributes: Sequence[str] = (),
    make_required: bool = False,
    **overrides: Any,
) -> FieldInfo:
    """Copy a FieldInfo instance, optionally overriding attributes and excluding some.

    Args:
        field_info: The FieldInfo instance to copy
        exclude_attributes: Attributes to exclude from the copied FieldInfo
        make_required: Whether to make the field required
        **overrides: Keyword arguments to override attributes

    Returns:
        A new FieldInfo instance with the specified overrides
    """
    field_kwargs: dict[str, Any] = {}
    for attr_name in _FromFieldInfoInputs.__annotations__.keys():
        if attr_name in exclude_attributes:
            continue

        attr_value = getattr(field_info, attr_name, None)
        if attr_value is not None:
            field_kwargs[attr_name] = attr_value

    field_kwargs.pop("annotation", None)
    field_kwargs.update(overrides)

    if make_required:
        field_kwargs.pop("default", None)
        field_kwargs.pop("default_factory", None)

    return field_info.from_field(**field_kwargs)


def _unwrap_pydantic_type(model_type: type[Any] | None) -> type[Any]:  # noqa: PLR0911, PLR0912
    """Recursively unwrap Pydantic model types to ensure compatibility.

    Args:
        model_type: The type to unwrap

    Returns:
        The unwrapped type
    """
    if model_type is None:
        return type(None)

    origin = get_origin(model_type)
    args = get_args(model_type)

    if origin is Annotated:
        base_type, *annotations = args
        filtered_annotations = [
            annotation
            for annotation in annotations
            if not isinstance(annotation, FieldInfo | Discriminator)
        ]

        unwrapped_base = _unwrap_pydantic_type(base_type)
        if filtered_annotations:
            return Annotated[unwrapped_base, *filtered_annotations]  # type: ignore

        return unwrapped_base

    if origin is list:
        return list[_unwrap_pydantic_type(args[0])]  # type: ignore

    if origin is dict:
        return dict[  # type: ignore
            _unwrap_pydantic_type(args[0]),
            _unwrap_pydantic_type(args[1]),
        ]

    if origin in (Union, UnionType):
        # Flatten nested Unions
        flat_args: list[Any] = []
        for arg in args:
            processed_arg = _unwrap_pydantic_type(arg)
            if get_origin(processed_arg) in (Union, UnionType):
                flat_args.extend(get_args(processed_arg))
            else:
                flat_args.append(processed_arg)

        # Remove duplicates while preserving order
        unique_args: list[Any] = []
        seen: set[Any] = set()
        for arg in flat_args:
            if arg not in seen:
                unique_args.append(arg)
                seen.add(arg)

        return union_type(unique_args)

    if is_pydantic_model(model_type):
        return remove_default_values(model_type)
    else:
        return copy(model_type)


def _replace_placeholder_with_default(
    instance: BaseModel,
    placeholder: Any,
    field_name: str,
    field_info: FieldInfo,
) -> bool:
    """Replace the placeholder with the default value if present.

    Args:
        instance: The model instance.
        placeholder: The placeholder value to replace.
        field_name: The name of the field.
        field_info: The field information.

    Returns:
        True if the placeholder was replaced, False otherwise.
    """
    if getattr(instance, field_name) != placeholder:
        return False

    default_container = next(
        (
            metadata
            for metadata in field_info.metadata
            if isinstance(metadata, DefaultValueContainer)
        ),
        None,
    )

    if default_container:
        setattr(instance, field_name, default_container.get_default())
        return True

    return False


def _restore_nested_models(field_type: Any, field_value: Any) -> Any:  # noqa: PLR0911
    """Restore default values for nested models, including handling Union types.

    Args:
        field_type: The type of the field.
        field_value: The current value of the field.

    Returns:
        The restored value
    """
    origin = get_origin(field_type)
    args = get_args(field_type)

    if origin is Annotated:
        base_type, *_annotations = args
        return _restore_nested_models(base_type, field_value)

    if origin is list and isinstance(field_value, list):
        item_type = args[0] if args else Any
        return [_restore_nested_models(item_type, item) for item in field_value]

    if origin is dict and isinstance(field_value, dict):
        value_type = args[1] if len(args) > 1 else Any
        return {
            key: _restore_nested_models(value_type, value) for key, value in field_value.items()
        }

    if origin in (Union, UnionType):
        for possible_type in args:
            try:
                if is_pydantic_model(possible_type):
                    model_instance = possible_type.model_validate(field_value)
                    return restore_default_values(model_instance, possible_type)
                else:
                    return field_value
            except (ValidationError, ValueError, TypeError):
                continue

        return field_value

    if isinstance(field_value, BaseModel):
        return restore_default_values(field_value, field_value.__class__)

    return field_value


def remove_default_values(model: type[BaseModel]) -> type[BaseModel]:
    """Transform a Pydantic model by removing default values.

    Creates a new model where all fields are made required without any default values.
    This is useful when working with systems that don't support default values in structural outputs.

    Args:
        model: The original Pydantic model

    Returns:
        A new Pydantic model with defaults removed
    """
    transformed_fields: dict[str, Any] = {}
    for field_name, field in model.model_fields.items():
        transformed_type: Any = _unwrap_pydantic_type(field.annotation)

        if not field.is_required():
            transformed_type = union_type([transformed_type, PLACEHOLDER_TYPE])

            updated_field = copy_field_info(
                field,
                exclude_attributes=("discriminator"),
                make_required=True,
            )

            updated_field.metadata = [
                *copy(field.metadata),
                DefaultValueContainer(value=field.default, factory=field.default_factory),
            ]

        else:
            updated_field = copy_field_info(
                field,
                exclude_attributes=("discriminator"),
            )

        transformed_fields[field_name] = (transformed_type, updated_field)

    try:
        transformed_model = create_model(
            f"{model.__name__}Transformed",
            __base__=model,
            **transformed_fields,
        )
    except TypeError as e:
        raise TypeError(
            f"Error creating transformed model '{model.__name__}Transformed': {e}"
        ) from e

    # Rebuild the original model to ensure consistency
    model.model_rebuild()

    return transformed_model


def restore_default_values(instance: T, target_model_type: type[V]) -> V:
    """Restore default values in a transformed model instance.

    Maps an instance of a transformed model (with placeholders) back to the
    original model by replacing placeholders with actual default values.

    Args:
        instance: The transformed model instance
        target_model_type: The original target Pydantic model type

    Returns:
        An instance of the original target model with defaults restored
    """
    union_values: dict[str, Any] = {}
    for field_name, field in instance.model_fields.items():
        replaced = _replace_placeholder_with_default(
            instance=instance,
            placeholder=PLACEHOLDER_VALUE,
            field_name=field_name,
            field_info=field,
        )

        if not replaced:
            if field.annotation is not None:
                field_value = getattr(instance, field_name)
                restored_value = _restore_nested_models(field.annotation, field_value)
                setattr(instance, field_name, restored_value)
            else:
                raise ValueError(
                    f"Error restoring default values for model '{target_model_type.__name__}': "
                    f"field '{field_name}' has no annotation"
                )

    # Dump the instance to a dict without warnings because we've already handled
    # the placeholders and we don't want to see warnings about them
    dumped_data = instance.model_dump(warnings=False)

    # Correct union fields to use the actual member values
    for field_name, value in union_values.items():
        if isinstance(value, BaseModel):
            dumped_data[field_name] = value.model_dump()
        else:
            dumped_data[field_name] = value

    try:
        return target_model_type.model_validate(dumped_data)
    except Exception as e:
        raise ValueError(
            f"Error restoring default values for model '{target_model_type.__name__}': {e}"
        ) from e


def change_field_type(  # noqa: PLR0913
    model_type: type[T],
    field_name: str,
    new_type: Any,
    new_model_type: type[T] | None = None,
    new_model_name: str | None = None,
    default: Any = PydanticUndefined,
    **kwargs: Unpack[_FromFieldInfoInputs],
) -> type[T]:
    """Create a new Pydantic model with a modified or added field.

    Creates a copy of the original model with one field modified or added,
    preserving all other fields and model configuration. The new model can:
    - Modify existing field types
    - Add new fields
    - Change base model type
    - Customize field validation

    Args:
        model_type: The original Pydantic model to modify
        field_name: Name of the field to modify or add
        new_type: New type for the field
        new_model_type: Optional new base model type (defaults to original model)
        new_model_name: Optional name for the new model (defaults to "Updated" + original name)
        default: Optional default value for the field
        **kwargs: Additional field configuration (validation rules, descriptions, etc.)

    Returns:
        A new Pydantic model class with the modified or added field

    Raises:
        TypeError: If the default value doesn't match the new field type
        ValidationError: If default value validation fails when validate_default=True

    Example:
    ```python
    class User(BaseModel):
        id: int
        name: str

    # Modify existing field
    UserStr = change_field_type(
        model_type=User,
        field_name="id",
        new_type=str,
        new_model_name="UserStr"
    )

    # Add new field
    UserWithAge = change_field_type(
        model_type=User,
        field_name="age",
        new_type=int,
        default=0,
        ge=0,
        description="User's age in years"
    )

    # Change base model and add validation
    class ValidatedModel(BaseModel):
        model_config = ConfigDict(validate_default=True)

    UserValidated = change_field_type(
        model_type=User,
        field_name="name",
        new_type=str,
        new_model_type=ValidatedModel,
        min_length=1,
        max_length=100
    )
    ```
    """
    fields: dict[str, Any] = {}
    if field := model_type.model_fields.get(field_name):
        field_info = copy_field_info(field, default=default, **kwargs)
        fields[field_name] = (new_type, field_info)
    else:
        fields[field_name] = (new_type, FieldInfo(default=default, **kwargs))

    for name, field_info in model_type.model_fields.items():
        if name != field_name:
            fields[name] = (field_info.annotation, field_info)

    if default is not PydanticUndefined and kwargs.get("validate_default"):
        try:
            fields = {field_name: (new_type, default)}
            temp_model = create_model("TempModel", **fields)
            temp_model(**{field_name: default})
        except ValidationError as e:
            raise TypeError(
                f"Default value {default!r} is not valid for field '{field_name}' of type {new_type}"
            ) from e

    updated_model_name = new_model_name or f"Updated{model_type.__name__}"

    new_model = create_model(
        updated_model_name,
        __base__=new_model_type or model_type,
        **fields,
    )

    return new_model
